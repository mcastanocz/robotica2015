\documentclass[letterpaper, 10 pt, conference]{ieeeconf}  
\IEEEoverridecommandlockouts                              
\overrideIEEEmargins

\title{
\LARGE\bf
\textbf{Component-Based Robotic Engineering (Part I)}
}

\author{Davide Brugali$^{1}$ and Patrizia Scandurra$^{2}$
\thanks{*This work was not supported by any organization}
\thanks{$^{1}$H. Brugali, Department of Computer Science and Mathematics,
        Universita' degli Studi di Bergamo, 24044 Dalmine, Italy.
        {\tt\small p.brugali at davide.brugali@unibg.it}}
\thanks{$^{2}$P. Scandurra degree in computer science, University of Catania, Italy.
        {\tt\small p.scandurra at ieee.org}}
}

\begin{document}
\maketitle
\thispagestyle{empty}
\pagestyle{empty}

\section{INTRODUCTION}

The focus of this article is on design and implementation guidelines that enable the development of reusable and maintainable software-building blocks, which can be assembled to build robotic applications.
CBSE is an approach that has arisen in the software engineering community in the last decade. It aims to shift the emphasis in system building from traditional requirement analysis, system design, and implementation to composing software systems from a mixture of reusable off-the-self and custom-built components.
Such an approach improves software development by reducing the amount of code that has to be written by the application designer.
Software reuse allows researches to more easily keep up the place of robotics research, since they do not have to constantly rewrite each other's code.
Today, most robotic research and development is still based on custom-designed software architectures invented from scratch each time.
During the last few years, many ideas from software engineering have been progressively introduced in the construction of robotic software systems to simplify their development and improve their quality.

\section{Reusable Software-Building Blocks}
A robot-software architecture describes the decomposition of the robot control system into a collection of software components, the encapsulation of functionality and control activities into components, and the flow of data and control information among components.
Three aspects of a reusable component are equally important: quality, technical reusability, and functional reusability.
Reusable components can be classified in two categories: 
\begin{itemize}
\item Horizontal components provide system services such as interfacing to hardware devices, providing computational or communication services, or implementing mathematic functions.
\item Vertical components capture a company, organization, or research community know-how in specific functional areas such as kinematics, motion planning, deliberative control, and address the requirements of target application domains such as service robotics, space robotics, or humanoid robotics.
\end{itemize}

\section{Component-Based Software Engineering}

A software component is a unit of composition with contractually specified interfaces and explicit context dependencies only. A software component can be deployed independently and is subject to composition by third parties.
A software component has a well-defined component specification, which is an abstraction of data structures, operations and implementations.

\section{Component Specification}

Interfaces are the external visible parts of the components, and components interact with each other through interfaces. Interfaces support the information hidden and protect the client code from changes in the component implementation. A given component may implement more than one interface, and an interface may be implemented by a number of different components. 


\subsection{Provided and Required Interfaces} 
A component has one or more provided and/or required interfaces:
\begin{itemize}
\item The provided interfaces of a component are a set of interfaces realized by the component. They represent the contractually specified functionality that the component offers to their clients. 
\item The required interfaces specify functionality and resources that the component needs to perform its own functions and fulfill its own obligations to its clients. 
\end{itemize}

\subsection{Data and Service Interfaces}
\begin{itemize}
\item Data interface exposes state information of components and makes it available to its clients. Data interfaces contain getter/setter operations for retrieving or set values of attributes.
\item A service interface is a declaration of a set of functionalities offered by a component operating mostly on the parameters that are passed to it rather than on the attributes of implementation.
\end{itemize}

\subsection{Strongly Typed Versus Loosely Typed Interfaces}
\begin{itemize}
\item Strongly typed interfaces allow exact descriptions of exchanged data objects by means of specific types.
\item Loosely typed interfaces define generic communication primitives called performance that correspond to a specific linguistic action and exchangue data represented using primitive data types, such as textual strings, and structured according to standard markup languages such as XML.
\end{itemize}

\subsection{Stateful Versus Stateless Interfaces}
\begin{itemize}
\item In a stateful interface, each operation invocation changes the component's internal state, and the information returned by the operation is computed differently based on the component's state.
\item In a stateless interface, the operations' behavior is always the same and depends only on the information supplied through their parameters.
\end{itemize}

\subsection{Different Interfaces for Different Clients}
\begin{itemize}
\item Minimal interfaces expose a minimum set of operations that allows the clients to access all common component functionality.
\item Complete interfaces expose additional operations that simplify the use or enhance the accessibility of those functionality in specific use cases.
\end{itemize}

\subsection{Some Common Mistakes}
An interface specifies a contract between the component implementation and its client. A contract can be seen as an explicit roster of mutual obligations expressed in the form of various kinds of constraints, such as preconditions, posconditions, invariants, and protocol specifications.

\section{COMPONENT IMPLEMENTATION}
Separation of component specification and implementation enables reuse of software components embedding common robotic functionality.
Component framework is a technique to clearly separate stable and variable aspects of a component implementation and illustrate variability implementation techniques that reduce the effort of developing new implementations of the same component specification.

\subsection{Component Framework}
A component framework captures commonalities among different implementations of similar components and points of variability to express the differences.

\subsection{Implementing Variability}
Variability is managed through different component-configuration mechanisms:
\begin{itemize}
\item Compile time: The variability is resolved before the program compilation or at compile time.
\item Link time: The variability is resolved during module or library linking. 
\item Run time: The variability is resolved during program execution.
\end{itemize}

\subsubsection{Inheritance and Extension}
Object inheritance is used to assign base functionality to superclasses and extensions to subclasses. Subclasses may introduce new attributes, operations, or overwrite or wrap existing ones.

\subsubsection{Aggregation and Delegation}
Aggregation is an object-oriented technique that enables an object to contain other objects. It may be done by value or by reference.

\subsubsection{Parameterization}
Parameterization avoid code replication by centralizing code decision around a set of variables.

\subsubsection{Conditional Compilation}
One benefit of this technique is the encapsulation of multiple implementations in a single module. The desired functionality is selected by defining the appropiate conditional symbols.

\section*{CONCLUSIONS}
We have illustrated the fundamental concepts and design guidelines for the development of software building blocks that embed reusable robot functionality. 

\section*{ACKNOWLEDGMENT}
The authors Mari Luz Castano y Byron Andres Morales thank Herman Bruyninckx, Stefan Christen, Edmund Milke y Walker Nowak. The research research is conducted in University of Extremadura in October 2015. 

\begin{thebibliography}{}

\bibitem{c1} G. T. Heineman and W. T. Councill, Component-Based Software Engineering: Putting the Pieces Together. Reading, MA: Addison-Wesley, June
2001.
\bibitem{c2} C. Szyperski, Component Software: Beyond Object-Oriented Programming. Reading, MA: Addison-Wesley, 2002.
\bibitem{c3} A. Shakhimardanov, H. Bruyninckx, K. Nilsson, and E. Prassler. (2009, June 19). White paper: The use of reuse for designing and manufacturing robots [Online]. Available: http://www.robot-standards.org/index.php?id=19
\bibitem{c4} D. Brugali, Ed., Software Engineering for Experimental Robotics (Springer Tracts in Advanced Robotics, vol. 30), Berlin: Springer-Verlag, Apr.2007.
\bibitem{c5}  D. Brugali and E. Prassler, ‘‘Software engineering for robotics,’’ Special Issue on IEEE Robot. Automat. Mag., vol. 16, no. 1, Mar. 2009.
\bibitem{c6} L. Bass, P. Clements, and R. Kazman, Software Architecture in Practice.Reading, MA: Addison Wesley, 1999.
\bibitem{c7} I. A. Nesnas, ‘‘The claraty project: Coping with hardware and software heterogeneity,’’ in Software Engineering for Experimental Robotics (Springer Tracts in Advanced Robotics, vol. 30), D. Brugali, Ed. Berlin, SpringerVerlag, Apr. 2007.
\bibitem{c8} J. Poulin, Measuring Software Reuse: Principles, Practices, and Economic Models. Reading, MA: Addison-Wesley, 1996.
\bibitem{c9} M. Ezran, M. Moriso, and C. Tully, Practical Software Reuse—The Essential Guide. Paris: Freelife Publ: ESSI Surprise Project Book.
\bibitem{c10}  J.-C. Latombe, F. Schwarzer, and M. Saha. (2004). Mpk—motion planning kit [Online]. Available: http://robotics.stanford.edu/mitul/mpk/
\bibitem{c11}  S. LaValle, P. Cheng, J. Kuffner, S. Lindemann, A. Manohar, B. Tovar,L. Yang, and A. Yershova. (2007). Msl—motion strategy library [Online]. Available: http://msl.cs.uiuc.edu/msl/
\bibitem{c12}  E. Milke, S. Christen, E. Prassler, and W. Nowak, ‘‘Towards harmonization and refactoring of mobile manipulation algorithms,’’ in Proc. ICAR 2009 14th Int. Conf. Advanced Robotics, Munich, Germany, June 22–26, 2009, pp. 1–8.
\bibitem{c13} G. Sanchez and J. Latombe, ‘‘A single-query bi-directional probabilistic roadmap planner with lazy collision checking,’’ in Proc. Int. Symp. Robotics Research (ISRR), 2001, pp. 403–417.
\bibitem{c14} K. Pugh, Interface Oriented Design. Odessa, TX: The Pragmatic Programmers LLC., 2006.
\bibitem{c15}  M. Reggiani, M. Mazzoli, and S. Caselli, ‘‘An experimental evaluation of collision detection packages for robot motion planning,’’ in Proc. IEEE/RSJ Int. Conf. Intelligent Robots and Systems, 2002, pp. 2329–2334.
\bibitem{c16} J. G. Wijnstra, ‘‘Components, interfaces and information models within a platform architecture,’’ in Proc. GCSE. (Lecture Notes in Computer Science, vol. 2186), J. Bosch, Ed. Berlin, Germany: Springer-Verlag, 2001, pp. 25–35.
\bibitem{c17} A. Tost (2005, Sept. 2). Loosely typed versus strongly typed web services. IBM [Online]. Available: http://www.ibm.com/’ developerworks/webservices/library/ws-loosevstrong.html
\bibitem{c18} B. Meyer, Object-Oriented Software Construction. Englewood Cliffs, NJ: Prentice Hall, 1997.
\bibitem{c19} M. E. Fayad and A. Altman, ‘‘An introduction to software stability,’’ Commun. ACM, vol. 44, no. 9, pp. 95–98, Sept. 2001.

\end{thebibliography}
\end{document}
